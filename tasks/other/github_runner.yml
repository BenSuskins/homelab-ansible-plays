---
- name: RUNNER - Create runner install directory
  ansible.builtin.file:
    path: "{{ runner_install_dir }}"
    state: directory
    owner: "{{ username }}"
    group: "{{ username }}"
    mode: "0755"

- name: RUNNER - Create ansible vault password file
  ansible.builtin.copy:
    content: "{{ ANSIBLE_VAULT_PASS }}"
    dest: "/home/{{ username }}/.ansible_vault_pass"
    owner: "{{ username }}"
    group: "{{ username }}"
    mode: "0600"

- name: RUNNER - Get latest runner release from GitHub
  ansible.builtin.uri:
    url: https://api.github.com/repos/actions/runner/releases/latest
    method: GET
    return_content: true
    headers:
      Accept: application/vnd.github.v3+json
  register: runner_release_info

- name: RUNNER - Extract runner version
  ansible.builtin.set_fact:
    runner_version: "{{ runner_release_info.json.tag_name | regex_replace('^v', '') }}"

- name: RUNNER - Check if runner is already installed
  ansible.builtin.stat:
    path: "{{ runner_install_dir }}/config.sh"
  register: runner_config_exists

- name: RUNNER - Check installed runner version
  ansible.builtin.command:
    cmd: "{{ runner_install_dir }}/bin/Runner.Listener --version"
  become: true
  become_user: "{{ username }}"
  register: installed_runner_version
  changed_when: false
  failed_when: false
  when: runner_config_exists.stat.exists

- name: RUNNER - Determine if install needed
  ansible.builtin.set_fact:
    runner_needs_install: >-
      {{ not runner_config_exists.stat.exists or
         (installed_runner_version.stdout is defined and
          installed_runner_version.stdout != runner_version) }}

- name: RUNNER - Download and install runner
  when: runner_needs_install | bool
  block:
    - name: RUNNER - Download runner archive
      ansible.builtin.get_url:
        url: "https://github.com/actions/runner/releases/download/v{{ runner_version }}/actions-runner-linux-x64-{{ runner_version }}.tar.gz"
        dest: "/tmp/actions-runner-{{ runner_version }}.tar.gz"
        mode: "0644"

    - name: RUNNER - Extract runner archive
      ansible.builtin.unarchive:
        src: "/tmp/actions-runner-{{ runner_version }}.tar.gz"
        dest: "{{ runner_install_dir }}"
        remote_src: true
        owner: "{{ username }}"
        group: "{{ username }}"

    - name: RUNNER - Cleanup downloaded archive
      ansible.builtin.file:
        path: "/tmp/actions-runner-{{ runner_version }}.tar.gz"
        state: absent

- name: RUNNER - Check if runner is configured
  ansible.builtin.stat:
    path: "{{ runner_install_dir }}/.runner"
  register: runner_configured

- name: RUNNER - Configure runner
  when: not runner_configured.stat.exists
  block:
    - name: RUNNER - Generate registration token
      ansible.builtin.uri:
        url: "https://api.github.com/orgs/{{ github_org }}/actions/runners/registration-token"
        method: POST
        headers:
          Accept: application/vnd.github.v3+json
          Authorization: "token {{ GITHUB_RUNNER_TOKEN }}"
        status_code: 201
        return_content: true
      register: registration_token_response

    - name: RUNNER - Configure runner with organization
      ansible.builtin.command:
        cmd: >
          ./config.sh
          --url https://github.com/{{ github_org }}
          --token {{ registration_token_response.json.token }}
          --name {{ inventory_hostname_short }}
          --unattended
          --replace
        chdir: "{{ runner_install_dir }}"
      become: true
      become_user: "{{ username }}"

- name: RUNNER - Check if systemd service exists
  ansible.builtin.stat:
    path: "/etc/systemd/system/actions.runner.{{ github_org }}.{{ inventory_hostname_short }}.service"
  register: runner_service_exists

- name: RUNNER - Install systemd service
  ansible.builtin.command:
    cmd: "./svc.sh install {{ username }}"
    chdir: "{{ runner_install_dir }}"
  when: not runner_service_exists.stat.exists

- name: RUNNER - Start and enable runner service
  ansible.builtin.systemd:
    name: "actions.runner.{{ github_org }}.{{ inventory_hostname_short }}"
    state: started
    enabled: true
    daemon_reload: true
